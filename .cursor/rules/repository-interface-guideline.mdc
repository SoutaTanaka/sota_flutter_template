---
description: 
globs: packages/domain/repository/**/*.dart
alwaysApply: false
---
# リポジトリインターフェースのコーディングガイドライン

## 目的

このガイドラインは、アプリケーション内でリポジトリパターンを実装する際の一貫性と保守性を確保するためのものです。リポジトリレイヤーは、データソースとビジネスロジックの間の橋渡しとして機能し、アプリケーションのアーキテクチャにおいて重要な役割を担います。

## 基本原則

1. **単一責任の原則**: 各リポジトリインターフェースは、単一のエンティティまたは関連するエンティティグループに対する操作のみを担当すべきです。
2. **依存性逆転の原則**: ビジネスロジックはリポジトリの具体的な実装ではなく、インターフェースに依存すべきです。
3. **インターフェースセグリゲーション**: 大きな汎用インターフェースよりも、複数の特化したインターフェースを優先します。

## 命名規則

- インターフェース名は扱うドメイン名に`Repository` サフィックスを付けます。例: `UserRepository`
  - 実装の際は必ずabstract interface classを使用してください。
- メソッド名は以下の接頭辞に従うべきです:
  - `get`: 単一のエンティティを取得
  - `getAll`: 複数のエンティティを取得
  - `find`: 条件に基づいて検索
  - `create`: 新しいエンティティを作成
  - `update`: 既存のエンティティを更新
  - `delete`: エンティティを削除
  - `exists`: エンティティの存在を確認

## インターフェース構造
```dart
/// ユーザーに関連する永続化操作を行うためのリポジトリインターフェース
abstract interface class UserRepository {
  /// 指定されたIDのユーザーを取得する
  ///
  /// [userId] 取得するユーザーのID
  ///
  /// 成功時は [User] オブジェクトを返す
  /// ユーザーが存在しない場合は [UserNotFoundException] をスローする
  Future<User> getUser(String userId);

  /// すべてのユーザーを取得する
  ///
  /// 成功時は [User] オブジェクトのリストを返す
  /// ユーザーが存在しない場合は空のリストを返す
  Future<List<User>> getAllUsers();

  /// 指定された役割を持つユーザーを検索する
  ///
  /// [role] 検索するユーザーの役割
  ///
  /// 条件に一致するユーザーのリストを返す
  /// 一致するユーザーが存在しない場合は空のリストを返す
  Future<List<User>> findUsersByRole(UserRole role);

  /// 新しいユーザーを作成する
  ///
  /// [user] 作成するユーザーのオブジェクト
  ///
  /// 成功時は保存された [User] オブジェクトを返す
  /// 作成に失敗した場合は [RepositoryException] をスローする
  Future<User> createUser(User user);

  /// 既存のユーザーを更新する
  ///
  /// [user] 更新するユーザーのオブジェクト
  ///
  /// 成功時は更新された [User] オブジェクトを返す
  /// ユーザーが存在しない場合は [UserNotFoundException] をスローする
  /// 更新に失敗した場合は [RepositoryException] をスローする
  Future<User> updateUser(User user);

  /// 指定されたIDのユーザーを削除する
  ///
  /// [userId] 削除するユーザーのID
  ///
  /// 削除に成功した場合は void を返す
  /// ユーザーが存在しない場合は [UserNotFoundException] をスローする
  /// 削除に失敗した場合は [RepositoryException] をスローする
  Future<void> deleteUser(String userId);

  /// 指定されたIDのユーザーが存在するかを確認する
  ///
  /// [userId] 確認するユーザーのID
  ///
  /// ユーザーが存在する場合は true、存在しない場合は false を返す
  Future<bool> existsById(String userId);
  
  /// ユーザー名とパスワードで認証を行う
  ///
  /// [username] ユーザー名
  /// [password] パスワード
  ///
  /// 認証に成功した場合はユーザーオブジェクトを返す
  /// 認証に失敗した場合は [AuthenticationException] をスローする
  Future<User> authenticateUser(String username, String password);
}
```

## dart docによるドキュメント化

すべてのリポジトリインターフェースとそのメソッドはdart docを使用して適切にドキュメント化する必要があります。以下のルールに従ってください：

1. **インターフェース**:
   - リポジトリの全体的な目的と責任を記述する
   - 関連するドメインエンティティを明示する

```dart
/// ユーザーエンティティの永続化を管理するリポジトリ
///
/// このリポジトリはユーザーの作成、取得、更新、削除などの
/// 基本的なCRUD操作を提供します。
abstract interface class UserRepository {
  // メソッド宣言
}
```

2. **メソッド**:
   - メソッドの目的を簡潔に説明する
   - すべてのパラメータを `[paramName]` 形式で文書化する
   - 戻り値の型と意味を説明する
   - スローされる可能性のある例外を記述する

```dart
/// 指定されたIDのユーザーを取得する
///
/// [userId] 取得するユーザーのID
///
/// 成功時は [User] オブジェクトを返す
/// ユーザーが存在しない場合は [UserNotFoundException] をスローする
Future<User> getUser(String userId);
```

## 戻り値の型

- すべての非同期操作は `Future` または `Stream` を返すべきです。
- 操作が失敗する可能性がある場合は例外をthrowするべきです。Result型は使用しないでください。
- `null` の戻り値は避け、空のコレクションや例外をthrowするべきです。

## エラーハンドリング

- リポジトリの実装での例外は、ドメイン固有の例外にマッピングすべきです。
- ネットワークエラーやデータベース接続の問題など、予期せぬ例外は適切に処理すべきです。
- リポジトリメソッドの規約として例外をドキュメント化します。

## ベストプラクティス

1. リポジトリメソッドは副作用を最小限に抑え、冪等性を保つべきです。
2. 大きなデータセットを扱う場合は、ページネーションやストリーミングを検討します。
3. リポジトリレイヤーでのビジネスロジックは最小限に抑え、主にデータアクセスと変換に焦点を当てます。

## アンチパターン

以下は、リポジトリパターンの実装において避けるべきアンチパターンです：

### 1. 機能やロールでリポジトリを分ける

一つのエンティティに対して、機能や役割に応じて複数のリポジトリを作成するのは避けるべきです。例えば：

```dart
// アンチパターン
abstract class UserRepository { ... }
abstract class AdminUserRepository { ... }
abstract class GuestUserRepository { ... }
```

**問題点**：
- どのリポジトリを使うべきか不明確になる
- ビジネスロジックが複数のリポジトリに散らばり、データの整合性が取れなくなる

**対策**：
- エンティティの責任範囲を明確にし、一つのエンティティに対して一つのリポジトリを定義する
- 状態更新に関わる振る舞いはエンティティやサービスに実装する
- リポジトリは単なるストレージへのアクセス手段として利用し、複雑なビジネスロジックを持たせない

### 2. 子エンティティに対して多数のリポジトリを作る

親子関係のあるエンティティに対して、それぞれ別々のリポジトリを作成するのは避けるべきです。例えば：

```dart
// アンチパターン
abstract class UserRepository { ... }
abstract class UserAddressRepository { ... }
abstract class UserContactRepository { ... }
```

**問題点**：
- エンティティ間の整合性を保つのが難しくなる
- ビジネスルールのチェックロジックをリポジトリが持たなければならなくなる
- チェック処理を迂回してデータ操作が行える危険性がある

**対策**：
- DDDの集約パターンを適用し、親エンティティを集約ルートとして扱う
- 子エンティティの操作は必ず親エンティティを通して行うようにする
- 集約全体を一つのリポジトリで管理する

### 3. 複雑なクエリをリポジトリで頑張って発行する

特定の画面や機能のために複雑なクエリをリポジトリに実装するのは避けるべきです。

**問題点**：
- リポジトリの実装が複雑化する
- メンテナンスが困難になる
- パフォーマンス問題を引き起こす可能性がある

**対策**：
- CommandとQueryを分離する（CQS原則）
- 複雑なクエリはQueryServiceとして別途実装する
- リポジトリはエンティティの永続化と基本的な取得操作に集中する

### 4. リポジトリインターフェースにビジネスロジックを含める

リポジトリインターフェースに特定のビジネスルールや状態遷移ロジックを含めるのは避けるべきです。

**問題点**：
- リポジトリの責任範囲が広がりすぎる
- ドメインロジックとデータアクセスロジックが混在する
- テストが困難になる

**対策**：
- ビジネスロジックはドメインモデルやサービスに実装する
- リポジトリはデータの永続化と取得に集中する

### 5. UIの状態をリポジトリに直接結合する

ユーザーインターフェースの状態管理をリポジトリに依存させるのは避けるべきです。

**問題点**：
- レイヤー間の依存関係が複雑になる
- 再利用性が下がる
- テストが困難になる

**対策**：
- プレゼンテーション層とドメイン層を明確に分離する
- 状態管理は専用のクラスやライブラリ（BlocやProviderなど）を使用する
- リポジトリはドメインレイヤーの一部として、UIから直接参照されないようにする 