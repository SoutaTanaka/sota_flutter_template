# リポジトリインターフェースのコーディングガイドライン

## 目的

このガイドラインは、アプリケーション内でリポジトリパターンを実装する際の一貫性と保守性を確保するためのものです。リポジトリレイヤーは、データソースとビジネスロジックの間の橋渡しとして機能し、アプリケーションのアーキテクチャにおいて重要な役割を担います。

## 基本原則

1. **単一責任の原則**: 各リポジトリインターフェースは、単一のエンティティまたは関連するエンティティグループに対する操作のみを担当すべきです。
2. **依存性逆転の原則**: ビジネスロジックはリポジトリの具体的な実装ではなく、インターフェースに依存すべきです。
3. **インターフェースセグリゲーション**: 大きな汎用インターフェースよりも、複数の特化したインターフェースを優先します。

## 実装ルール
- 実装の際は必ずabstract interface classを使用してください。
- 実装するファイルのパスは`packages/domain/repository/lib/src/<ドメイン名>_repository.dart`とします。

## 命名規則

- インターフェース名は扱うドメイン名に`Repository` サフィックスを付けます。例: `UserRepository`
- メソッド名は以下の接頭辞に従うべきです:
  - `get`: 単一のエンティティを取得
  - `getAll`: 複数のエンティティを取得
  - `find`: 条件に基づいて検索
  - `create`: 新しいエンティティを作成
  - `update`: 既存のエンティティを更新
  - `delete`: エンティティを削除
  - `exists`: エンティティの存在を確認

## インターフェース構造
```dart
/// ユーザーに関連する永続化操作を行うためのリポジトリインターフェース
abstract interface class UserRepository {
  /// 指定されたIDのユーザーを取得する
  ///
  /// [userId] 取得するユーザーのID
  ///
  /// 成功時は [User] オブジェクトを含む [Success] を返す
  /// ユーザーが存在しない場合や取得に失敗した場合は [Failure] を返す
  Future<Result<User>> getUser(String userId);

  /// すべてのユーザーを取得する
  ///
  /// 成功時は [User] オブジェクトのリストを含む [Success] を返す
  /// 取得に失敗した場合は [Failure] を返す
  Future<Result<List<User>>> getAllUsers();

  /// 指定された役割を持つユーザーを検索する
  ///
  /// [role] 検索するユーザーの役割
  ///
  /// 成功時は条件に一致するユーザーのリストを含む [Success] を返す
  /// リストは空の場合もあります
  /// 検索に失敗した場合は [Failure] を返す
  Future<Result<List<User>>> findUsersByRole(UserRole role);

  /// 新しいユーザーを作成する
  ///
  /// [user] 作成するユーザーのオブジェクト
  ///
  /// 成功時は保存された [User] オブジェクトを含む [Success] を返す
  /// 作成に失敗した場合は [Failure] を返す
  Future<Result<User>> createUser(User user);

  /// 既存のユーザーを更新する
  ///
  /// [user] 更新するユーザーのオブジェクト
  ///
  /// 成功時は更新された [User] オブジェクトを含む [Success] を返す
  /// ユーザーが存在しない場合や更新に失敗した場合は [Failure] を返す
  Future<Result<User>> updateUser(User user);

  /// 指定されたIDのユーザーを削除する
  ///
  /// [userId] 削除するユーザーのID
  ///
  /// 削除に成功した場合は void を含む [Success] を返す
  /// ユーザーが存在しない場合や削除に失敗した場合は [Failure] を返す
  Future<Result<void>> deleteUser(String userId);

  /// 指定されたIDのユーザーが存在するかを確認する
  ///
  /// [userId] 確認するユーザーのID
  ///
  /// 成功時は存在確認結果の真偽値を含む [Success] を返す
  /// 確認に失敗した場合は [Failure] を返す
  Future<Result<bool>> existsById(String userId);
  
  /// ユーザー名とパスワードで認証を行う
  ///
  /// [username] ユーザー名
  /// [password] パスワード
  ///
  /// 認証に成功した場合はユーザーオブジェクトを含む [Success] を返す
  /// 認証に失敗した場合は [Failure] を返す
  Future<Result<User>> authenticateUser(String username, String password);
}
```

## dart docによるドキュメント化

すべてのリポジトリインターフェースとそのメソッドはdart docを使用して適切にドキュメント化する必要があります。以下のルールに従ってください：

1. **インターフェース**:
   - リポジトリの全体的な目的と責任を記述する
   - 関連するドメインエンティティを明示する

```dart
/// ユーザーエンティティの永続化を管理するリポジトリ
///
/// このリポジトリはユーザーの作成、取得、更新、削除などの
/// 基本的なCRUD操作を提供します。
abstract interface class UserRepository {
  // メソッド宣言
}
```

2. **メソッド**:
   - メソッドの目的を簡潔に説明する
   - すべてのパラメータを `[paramName]` 形式で文書化する
   - 戻り値の型と意味を説明する
   - 成功時と失敗時の結果を記述する

```dart
/// 指定されたIDのユーザーを取得する
///
/// [userId] 取得するユーザーのID
///
/// 成功時は [User] オブジェクトを含む [Success] を返す
/// ユーザーが存在しない場合や取得に失敗した場合は [Failure] を返す
Future<Result<User>> getUser(String userId);
```

## 戻り値の型

- すべての非同期操作は `Future<Result<T>>` または `Stream<Result<T>>` を返すべきです。
- `Result`型は成功（`Success`）と失敗（`Failure`）の両方のケースをカプセル化します。
- 失敗の場合は、`Failure`に適切な`DomainException`を含めるべきです。
- `null`の戻り値は避け、空のコレクションや`Result`型で適切にハンドリングするべきです。

## エラーハンドリング

- リポジトリの実装での例外は、ドメイン固有の例外にマッピングし、`Result.failure()`で返すべきです。
- ネットワークエラーやデータベース接続の問題など、予期せぬ例外は適切な`DomainException`に変換して返すべきです。
- リポジトリメソッドの規約として失敗時の結果をドキュメント化します。

## ベストプラクティス

1. リポジトリメソッドは副作用を最小限に抑え、冪等性を保つべきです。
2. 大きなデータセットを扱う場合は、ページネーションやストリーミングを検討します。
3. リポジトリレイヤーでのビジネスロジックは最小限に抑え、主にデータアクセスと変換に焦点を当てます。

## アンチパターン

以下は、リポジトリパターンの実装において避けるべきアンチパターンです：

### 1. 機能やロールでリポジトリを分ける

一つのエンティティに対して、機能や役割に応じて複数のリポジトリを作成するのは避けるべきです。例えば：

```dart
// アンチパターン
abstract class UserRepository { ... }
abstract class AdminUserRepository { ... }
abstract class GuestUserRepository { ... }
```

**問題点**：
- どのリポジトリを使うべきか不明確になる
- ビジネスロジックが複数のリポジトリに散らばり、データの整合性が取れなくなる

**対策**：
- エンティティの責任範囲を明確にし、一つのエンティティに対して一つのリポジトリを定義する
- 状態更新に関わる振る舞いはエンティティやサービスに実装する
- リポジトリは単なるストレージへのアクセス手段として利用し、複雑なビジネスロジックを持たせない

### 2. 子エンティティに対して多数のリポジトリを作る

親子関係のあるエンティティに対して、それぞれ別々のリポジトリを作成するのは避けるべきです。例えば：

```dart
// アンチパターン
abstract class UserRepository { ... }
abstract class UserAddressRepository { ... }
abstract class UserContactRepository { ... }
```

**問題点**：
- エンティティ間の整合性を保つのが難しくなる
- ビジネスルールのチェックロジックをリポジトリが持たなければならなくなる
- チェック処理を迂回してデータ操作が行える危険性がある

**対策**：
- DDDの集約パターンを適用し、親エンティティを集約ルートとして扱う
- 子エンティティの操作は必ず親エンティティを通して行うようにする
- 集約全体を一つのリポジトリで管理する

### 3. 複雑なクエリをリポジトリで頑張って発行する

特定の画面や機能のために複雑なクエリをリポジトリに実装するのは避けるべきです。

**問題点**：
- リポジトリの実装が複雑化する
- メンテナンスが困難になる
- パフォーマンス問題を引き起こす可能性がある

**対策**：
- CommandとQueryを分離する（CQS原則）
- 複雑なクエリはQueryServiceとして別途実装する
- リポジトリはエンティティの永続化と基本的な取得操作に集中する

### 4. リポジトリインターフェースにビジネスロジックを含める

リポジトリインターフェースに特定のビジネスルールや状態遷移ロジックを含めるのは避けるべきです。

**問題点**：
- リポジトリの責任範囲が広がりすぎる
- ドメインロジックとデータアクセスロジックが混在する
- テストが困難になる

**対策**：
- ビジネスロジックはドメインモデルやサービスに実装する
- リポジトリはデータの永続化と取得に集中する

### 5. UIの状態をリポジトリに直接結合する

ユーザーインターフェースの状態管理をリポジトリに依存させるのは避けるべきです。

**問題点**：
- レイヤー間の依存関係が複雑になる
- 再利用性が下がる
- テストが困難になる

**対策**：
- プレゼンテーション層とドメイン層を明確に分離する
- 状態管理は専用のクラスやライブラリ（BlocやProviderなど）を使用する
- リポジトリはドメインレイヤーの一部として、UIから直接参照されないようにする 